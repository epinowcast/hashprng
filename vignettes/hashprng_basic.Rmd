---
title: "Hash-based Matched Pseudo-Random Number Generation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hashprng-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r setup, echo=FALSE}
library(hashprng)
# used for data transformation + plotting
library(data.table)
library(ggplot2)
library(patchwork)
# for compute time
library(parallel)
```

# Overview

This vignette demonstrates the practical use of `hashprng::set.seed`; if you
want a detailed explanation of *why* and *when* to use this approach, read the
paper associated with the package citation: (TODO).

Briefly, hash-matched pseudo-random number generation (HPRNG) ensures that the
same "events" across different simulation scenarios are resolved consistently,
while also still permitting stochastic simulation. This will allow simulations
to control for irrelevant random effects, much like matched comparisons in
non-synthetic studies.

Researchers still need to specify what constitutes "the same" event, and how to
resolve those events consistently. In this vignette, we focus on how to use
`hashprng::set.seed` and the overriden deviate generators from `stats`. For
different phenomena, questions, and models, researchers will need to identify
and implement the appropriate matching.

# Standards of Matching

Throughout this vignette we consider a few matching regimes:

 - Non-matched (NON): this is equivalent to drawing an item from a random
 process, then one from the slightly-perturbed process, and comparing them.
 - Seed-Matched-Only (SMO): this scheme ensures that compared draws have the
 same PRNG seeding. This can guarantee, for example, that history leading up
 to an intervention is the same. However, generally once simulation trajectory
 diverges, the PRNG is exercised differently, and events that _should_ be the
 same between runs are not guaranteed to see the same PRNG draws.
 - Fully-Event-Matched (FEM): this scheme ensures that compared runs have all of
 their identical events resolved consistently. Any event which occurs in both
 simulations gets the same draw from the PRNG.

HPRNG is an approach to achieving FEM simulations. There are alternatives, for
example managing multiple PRNGs or precomputing all possible outcomes. In
general, HPRNG imposes a guaranteed-but-low computational cost, scaling with the
number of the PRNG draws and event-identity-complexity.

# Model World and Scenario

Consider a infectious disease system of the *S*usceptible-*I*nfectious-*R*emoved
variety and an intervention where, after some delay from initial infection
introduction, a portion of the population are spontaneously moved to *R*
(representing e.g. a reactive vaccination campaign).

# Model Implementation

We'll implement this model in terms of discrete time steps, discrete
individuals, and event probabilities. At each time step:

1. We'll consider if infectious individuals have exposing contact with
susceptible individuals - this converts *S* to *I* at the end of the step.
2. We'll consider if infectious individuals recover - *I* to *R*.
3. If it's time for the move, we'll consider which susceptible individuals to
remove - *S* to *R*.

This is essentially the classic Reed-Frost model, except that people may be
infectious for more than a single time step (as well as introducing an
intervention). We'll implement this model with two distinct definitions of
identical events:

 - If individuals have identity, then events are distinguished by *who* is
involved in addition to *what* and *when*.
 - If they do not, then events are only distinguished by *what* and
*when*.

## Non-Identity Model Implementation

For the non-identity model, we assume that at each time step only the *size* of
the relative populations should determine event outcomes, e.g. how many people
are infected. We can accomplish that by drawing from the binomial distribution.

For FEM, we need to match time and event.

```{r nonident}
#' @param t an integer scalar, the simulation time
#' @param y an integer vector, the current counts of individuals in S, I, and R
#' @param parameters a list, `transmission_p`, `recovery_p`, `vaccination_p`,
#'   and `vax_t`
#' @param seed optional; if non-null, using HBM
m_dStep_NI <- function(t, y, parameters) {
  with(parameters, {
    # compute infection, recovery ignoring individual identities
    newinf <- rbinom(
      1, y["S"], 1 - (1 - transmission_p)^y["I"], hash = list("I", t)
    )
    newrem <- rbinom(1, y["I"], recovery_p, hash = list("R", t))

    # move infectees S -> I, recoveries I -> R
    dY <- c(S = -newinf, I = newinf - newrem, R = newrem)

    if (t == vax_t) { # if time for intervention, vaccinate some susceptible
      newvax <- rbinom(1, y["S"] - newinf, vaccination_p, hash = list("V", t))
      dY["S"] <- dY["S"] - newvax
      dY["R"] <- dY["R"] + newvax
    }

    # return the overall state change, as well as new incidence explicitly
    return(list(dY, newinf))
  })
}

# the version with no matching: use stats::rbinom without hashing info
u_dStep_NI <- function(t, y, parameters) {
  with(parameters, {
    newinf <- stats::rbinom(1, y["S"], 1 - (1 - transmission_p) ^ y["I"])
    newrem <- stats::rbinom(1, y["I"], recovery_p)

    dY <- c(S = -newinf, I = newinf - newrem, R = newrem)

    if (t == vax_t) {
      newvax <- stats::rbinom(1, y["S"] - newinf, vaccination_p)
      dY["S"] <- dY["S"] - newvax
      dY["R"] <- dY["R"] + newvax
    }

    return(list(dY, newinf))
  })
}
```

## Individual-specific Events

For the identity based model, we assume who *particularly* gets infected or
vaccinated matters. Thus, for HBM we need to hash both *who* and *when* for
infection and recovery.

```{r stepfunction}
#' @param t an integer scalar, the simulation time
#' @param y an integer vector, the individual states: S, I, R
#' @param parameters a list, `transmission_p`, `recovery_p`, `vaccination_p`,
#'   and `vax_t`
#' @param salt an integer scalar, optional; if present, use hash-based matching
m_dStep_ID <- function(t, y, parameters) {
  with(parameters, {
    N <- length(y)
    dY <- integer(N)
    infectable <- which(y == 1)
    infectors <- which(y == 2)
    for (infector in infectors) {
      expose <- (runif(
        N, hash = list("I", infector, t)) < transmission_p
      )[infectable]
      dY[infectable] <- dY[infectable] + expose
    }
    dY[dY > 0] <- 1
    incI <- sum(dY == 1)
    # if its time for vaccination
    if (t == vax_t) {
      vaxable <- setdiff(infectable, which(dY == 1))
      # for people still susceptible, indicate 1 => 3 transition
      dY[vaxable] <- 2 * (runif(N, hash = list("V")) < vaccination_p)[vaxable]
    }

    dY[infectors] <- 1 * (
      runif(N, hash = list("R", t)) < recovery_p
    )[infectors]

    return(list(dY, incI))
  })
}

u_dStep_ID <- function(t, y, parameters) {
  with(parameters, {
    dY <- integer(length(y))
    infectable <- y == 1
    infectors <- y == 2
    incI <- stats::rbinom(
      1, sum(infectable), 1 - (1 - transmission_p) ^ sum(infectors)
    )
    infectees <- base::sample(
      which(infectable), incI, replace = FALSE
    )
    recI <- stats::rbinom(1, sum(infectors), recovery_p)
    recoverees <- base::sample(which(infectors), recI, replace = FALSE)
    dY[infectees] <- 1
    dY[recoverees] <- 1

    # if its time for vaccination
    if (t == vax_t) {
      vaxI <- stats::rbinom(
        1, sum(infectable) - length(infectees), vaccination_p
      )
      vaccinees <- base::sample(
        setdiff(which(infectable), infectees), vaxI, replace = FALSE
      )
      # for people still susceptible, indicate 1 => 3 transition
      dY[vaccinees] <- 2
    }

    return(list(dY, incI))
  })
}
```

# Comparison

Let's run these simulation for a population of 4000 individuals, 75 time steps,
and 500 samples. We'll consider a very small amount of vaccination - only 3.3%.
We want to assess the cumulative averted _incidence_ of this scenario compared
to no vaccination.

For the "non-matching" version, we will still match on random number seeds; we
refer to that as seed-matched-only, or SMO. Because our model starts vaccination
after some delay, we should still see absolutely identical outcomes for SMO up
to that point. However, after that point, the RNG will see a different traversal.

We're going to discard outcomes were the epidemic dies out prior to vaccination.
This is a debate-worthy choice - e.g. if we want to understand the potential
benefit of purchasing some program, that should include the possibility that it
was unnecessary. For this model world, however, those sort of considerations
apply equally to either HBM or SMO, and we want to focus on the ability to
resolve intervention impact when there is an epidemic. Hence, we discard those
outcomes.

```{r parameters}
# setup parameters
samplen <- 1000L
pop <- 4000L
maxt <- 75L
initI <- 5L
ps <- list(
  transmission_p = 1 - exp(-0.78 / pop),
  # ~ 0.78 infections produced per day in fully susceptible pop
  recovery_p = 1 - exp(-0.44) # ~ 2.3 days infectious
  # implies R0 ~ 1.8
)
# non-intervention, set vax_t < 0
nonps <- c(ps, list(
  vax_t = -1, vaccination_p = NA
))
# intervention, vax_t == 10, 3.3% chance to happen
intps <- c(ps, list(
  vax_t = 10, vaccination_p = 0.033
))
# create populations; S = 1, I = 2, R = 3 for individual pop
yinit <- rep(1, pop)
yinit[1:initI] <- 2
yinit_nonid <- c(S = pop - initI, I = initI, R = 0L)

stepper <- function(maxtime = maxt, y0, dFUN, pars, seed, HBM) {

  # matching scenario
  if (!missing(seed)) {
    if (HBM) {
      set.salt(seed) # FEM
      environment(dFUN) <- environment()
    } else {
      set.seed(seed) # SMO
    }
  } else {
    # NON
  }

  # reserve data structure
  res <- integer(maxtime + 1)
  res[1] <- initI
  y <- y0
  # run the simulation
  for (i in seq_len(maxtime)) {
    dY <- dFUN(i, y, pars)
    y[] <- y[] + dY[[1]]
    res[i + 1] <- dY[[2]]
  }

  return(res)
}
```

# Sampling

Now we run all the samples, using plain sample ID as the SMO seed or HBM salt,
for all the models.

```{r runsamples}
set.seed(8675309) # will ensure repeatable NON results, even though not matched

nonid_no_match <- system.time(
  ni_non_dt <- seq_len(samplen) |> parallel::mclapply(function(seed) {
    data.table(
      type = "NON", model = "nonID",
      not_i = cumsum(stepper(
        y0 = yinit_nonid, dFUN = u_dStep_NI, pars = nonps
      )),
      withi = cumsum(stepper(
        y0 = yinit_nonid, dFUN = u_dStep_NI, pars = intps
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

set.seed(8675309)
id_no_match <- system.time(
  wi_non_dt <- seq_len(samplen) |> parallel::mclapply(function(seed) {
    data.table(
      type = "NON", model = "ID",
      not_i = cumsum(stepper(
        y0 = yinit, dFUN = u_dStep_ID, pars = nonps
      )),
      withi = cumsum(stepper(
        y0 = yinit, dFUN = u_dStep_ID, pars = intps
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

nonid_seed_match_only <- system.time(
  ni_smo_dt <- seq_len(samplen) |> parallel::mclapply(function(seed) {
    data.table(
      type = "SMO", model = "nonID",
      not_i = cumsum(stepper(
        y0 = yinit_nonid, dFUN = u_dStep_NI, pars = nonps, seed = seed,
        HBM = FALSE
      )),
      withi = cumsum(stepper(
        y0 = yinit_nonid, dFUN = u_dStep_NI, pars = intps, seed = seed,
        HBM = FALSE
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

id_seed_match_only <- system.time(
  wi_smo_dt <- seq_len(samplen) |> parallel::mclapply(function(seed) {
    data.table(
      type = "SMO", model = "ID",
      not_i = cumsum(stepper(
        y0 = yinit, dFUN = u_dStep_ID, pars = nonps, seed = seed, HBM = FALSE
      )),
      withi = cumsum(stepper(
        y0 = yinit, dFUN = u_dStep_ID, pars = intps, seed = seed, HBM = FALSE
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

nonid_hash_based_matching <- system.time(
  ni_hbm_dt <- seq_len(samplen) |> mclapply(function(seed) {
    data.table(
      type = "FEM", model = "nonID",
      not_i = cumsum(stepper(
        y0 = yinit_nonid, dFUN = m_dStep_NI, pars = nonps, seed = seed,
        HBM = TRUE
      )),
      withi = cumsum(stepper(
        y0 = yinit_nonid, dFUN = m_dStep_NI, pars = intps, seed = seed,
        HBM = TRUE
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

id_hash_based_matching <- system.time(
  wi_hbm_dt <- seq_len(samplen) |> mclapply(function(seed) {
    data.table(
      type = "FEM", model = "ID",
      not_i = cumsum(stepper(
        y0 = yinit, dFUN = m_dStep_ID, pars = nonps, seed = seed, HBM = TRUE
      )),
      withi = cumsum(stepper(
        y0 = yinit, dFUN = m_dStep_ID, pars = intps, seed = seed, HBM = TRUE
      ))
    )
  }, mc.cores = 5) |>
    rbindlist(idcol = "sample")
)

sampledt <- rbind(
  ni_non_dt, ni_smo_dt, ni_hbm_dt, wi_non_dt, wi_smo_dt, wi_hbm_dt
)
```
Timings:

```{r timings, echo=FALSE}
print("Non-matched (NON), non-identity:")
print(nonid_no_match)
print("Seed-Match-Only (SMO), non-identity:")
print(nonid_seed_match_only)
print("Hash-Based Match (HBM), non-identity:")
print(nonid_hash_based_matching)
print("Non-matched (NON), with identity:")
print(id_no_match)
print("Seed-Match-Only (SMO), with identity:")
print(id_seed_match_only)
print("Hash-Based Match (HBM), with identity:")
print(id_hash_based_matching)
```

Now we compute the difference in series, and determine if there are any to drop:

```{r summarycalcs}
sampledt[, averted := not_i - withi]
sampledt[, time := seq_len(.N) - 1L, by = .(type, model, sample)]

qtiled_dt <- sampledt[,
  {
    qs <- quantile(averted, probs = c(0.25, 0.5, 0.75))
    .(lo = qs[1], md = qs[2], hi = qs[3])
  },
  by = .(type, model, time)
]
```

... and lastly, we should visualize these

```{r sharedplot, echo=FALSE}
shared <- list(
  facet_grid(. ~ model, labeller = labeller(
    model = c(ID = "Individuals Matched", nonID = "Populations Matched")
  )),
  scale_color_manual(
    "Matching", guide = guide_legend(override.aes = list(alpha = 1)),
    values = c(NON = "firebrick", SMO = "black", FEM = "dodgerblue"),
    labels = c(NON = "None", SMO = "Seeds Only", FEM = "Fully Matched"),
    breaks = c("NON", "SMO", "FEM")
  ),
  scale_fill_manual(
    "Matching",
    values = c(NON = "firebrick", SMO = "black", FEM = "dodgerblue"),
    labels = c(NON = "None", SMO = "Seeds Only", FEM = "Fully Matched"),
    breaks = c("NON", "SMO", "FEM")
  ),
  scale_x_continuous(
    "Simulation Time", limits = c(0, 75), breaks = seq(0, 75, by = 25)
  ),
  scale_y_continuous("Infections Averted"),
  theme_minimal(),
  theme(
    legend.position = "inside",
    legend.position.inside = c(1, 1) - 0.05, legend.justification = c(1, 1)
  )
)
```

```{r spaghetti, echo=FALSE, out.width="100%"}
p_spag <- ggplot(sampledt) +
  aes(time, averted, color = type, group = interaction(type, sample)) +
  geom_line(alpha = 0.2) +
  shared
p_spag
```

```{r ribbons, echo=FALSE, out.width="100%"}
p_ribbon <- ggplot(qtiled_dt) +
  aes(time) +
  geom_ribbon(aes(fill = type, ymax = hi, ymin = lo), alpha = 0.25) +
  geom_line(aes(color = type, y = md)) +
  shared
p_ribbon
```

```{r noncrazyribbons, echo=FALSE, out.width="100%"}
p_ribbon_zoom <- ggplot(qtiled_dt) +
  aes(time) +
  geom_ribbon(aes(fill = type, ymax = hi, ymin = lo), alpha = 0.25) +
  geom_line(aes(color = type, y = md)) +
  shared + coord_cartesian(ylim = c(-25, 275), expand = FALSE)
p_ribbon_zoom
```
# Summary

```{r allplots, echo=FALSE}
p_combo <- ((
  p_spag + theme(
    axis.title = element_blank(), axis.text.x = element_blank()
  ) + guides(color = "none")
) / (
  p_ribbon + theme(
    strip.text.x = element_blank(), strip.background.x = element_blank(),
    axis.title.x = element_blank(), axis.text.x = element_blank()
  )
) / (
  p_ribbon_zoom + theme(
    axis.title.y = element_blank(), strip.text.x = element_blank(),
    strip.background.x = element_blank())
) / guide_area()) +
  plot_layout(heights = c(3, 3, 3, 0.5), guides = "collect") &
  theme(legend.direction = "horizontal", panel.spacing.x = unit(1.5, "line"))
p_combo
```
