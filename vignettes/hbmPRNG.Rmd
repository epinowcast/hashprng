---
title: "Hash-based Matched Pseudo-Random Number Generation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hbmPRNG}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hbmPRNG)
# required for vignette knitting only
library(Rcpp)
# used for data transformation + plotting
library(data.table)
library(ggplot2)
```

# Overview

This vignette demonstrates the practical use of `hbmPRNG::hash_seed`; if you
want explanation of *why* to use this approach, read the paper associated with
the package citation: (TODO).

Hash-based matched pseudo-random number generation (HBMPRNG) ensures that the
same "events" across different simulation scenarios are resolved consistently,
while also enabling sampling within a scenario.

# Model World and Scenario

Let's consider an infectious disease system of the *S*usceptible-*I*nfectious-
*R*emoved variety and an intervention where, after an epidemic starts to take
off, some portion of the population are spontaneously moved to *R* (representing
e.g. a reactive vaccination campaign).

We'll implement this model in terms of discrete time steps, discrete
individuals, and event probabilities. At each time step:

1. We'll consider if infectious individuals have exposing contact with
susceptible individuals - this converts *S* to *I* at the end of the step.
2. We'll consider if infectious individuals recover - *I* to *R*.
3. If it's time for the move, we'll consider which susceptible individuals to
remove - *S* to *R*.

We're also going to implement this model with a switch for whether or not to use
hash-based matching for the random number draws. We'll use this switch to show
matching-vs-not changes conclusions comparing across scenarios, as well as to
measure the resource cost associated with the higher resolution measurement.

```{r stepfunction}
susceptible <- 1
infectious  <- 2
removed     <- 3

#' @param t an integer scalar, the simulation time
#' @param y a factor vector, the individual states: S, I, R
#' @param parameters a list, `transmission_p`, `recovery_p`, `vaccination_p`,
#'   and `vax_t`
#' @param salt an integer scalar, optional; if present, use hash-based matching
dStep <- function(t, y, parameters, salt = NULL) with(parameters, {
  N <- length(y)
  dY <- integer(N)
  incI <- 0
  # consider whether each infectious individual exposes susceptible
  # individuals
  for (infector in which(y == infectious)) {
    # if HBM, reseed RNG
    if (!is.null(salt)) hash_seed(salt, "inf", infector, t)
    # draw all the potential exposures, indicate 1 => 2 transition for infectees
    exposures <- runif(N) < transmission_p
    dY[exposures & (y == susceptible)] <- 1
    # if this infector would recovery, indicate 2 => 3 transition
    if(runif(1) < recovery_p) dY[infector] <- 1
  }
  incI <- sum((dY == 1) & (y != infectious))
  
  # if its time for vaccination
  if (t == vax_t) {
    # if HBM, reseed
    if (!is.null(salt)) hash_seed(salt, "vax")
    # draw all potential vaccinations
    vaccinees <- runif(N) < vaccination_p
    # for people still susceptible, indicate 1 => 3 transition
    dY[vaccinees & (y == susceptible)] <- 2
  }

  return(list(dY, incI))
})
```

# Comparison

Let's run this simulation for a population of 4000 individuals, 200 time steps,
and 1000 samples. We'll consider a very small amount of vaccination - only 5%.
We want to assess the cumulative averted _incidence_ of this scenario compared
to no vaccination.

For the "non-matching" version, we will still match on random number seeds.
Because our model starts vaccination after some delay, we should still see
absolutely identical outcomes up to that point. However, after that point,
the RNG will see a different traversal.

```{r parameters}
# setup parameters
pop <- 4000
maxt <- 75
ps <- list(
  transmission_p = 1 - exp(-0.78/pop),
   # ~ 0.78 infections produced per day in fully susceptible pop
  recovery_p = 1 - exp(-0.44) # ~ 2.3 days infectious
  # implies R0 ~ 1.8
)
# non-intervention, set vax_t < 0
nonps <- c(ps, list(
  vax_t = -1, vaccination_p = NA
))
# intervention, vax_t == 10, 5% chance to happen
intps <- c(ps, list(
  vax_t = 10, vaccination_p = 0.033
))
# create population; initially infectious individual will be set in stepper
yinit <- rep.int(susceptible, pop)

stepper <- function(
  dFUN = dStep, maxtime = maxt, y0 = yinit,
  pars, seed, HBM = FALSE
) {
  
  # set initial seeding
  if (!HBM) { 
    set.seed(seed)
  } else {
    hash_seed(seed, "pat0")
  }
  # set initial infectee
  i0 <- sample(length(y0), 1) 

  # reserve data structure
  res <- integer(maxtime + 1)
  res[1] <- 1
  y <- y0
  y[i0] <- infectious
  # run the simulation
  for (i in seq_len(maxtime)) {
    dY <- if (HBM) dFUN(i, y, pars, seed) else dFUN(i, y, pars)
    y <- y + dY[[1]]
    res[i+1] <- dY[[2]]
  }

  return(res)
}
```

# Sampling

```{r runsamples}
seed_match_only <- system.time(
  smo_dt <- seq_len(100) |> lapply(function(seed) data.table(
    type = "SMO",
    not_i = cumsum(stepper(pars = nonps, seed = seed)),
    withi = cumsum(stepper(pars = intps, seed = seed))
  )) |> rbindlist(idcol = "sample")
)

hash_based_matching <- system.time(
  hbm_dt <- seq_len(100) |> lapply(function(seed) data.table(
    type = "HBM",
    not_i = cumsum(stepper(pars = nonps, seed = seed)),
    withi = cumsum(stepper(pars = intps, seed = seed))
  )) |> rbindlist(idcol = "sample")
)

sampledt <- rbind(smo_dt, hbm_dt)
```
Timings:

```{r timings, echo=FALSE}
print(seed_match_only)
print(hash_based_matching)
```

Difference in series:

```{r spaghetti, echo=FALSE}
sampledt[, averted := not_i - withi]
sampledt[, time := seq_len(.N) - 1L, by = .(type, sample)]

ggplot(sampledt) +
  aes(time, averted, color = type, group = interaction(type, sample)) +
  geom_line(alpha = 0.2) +
  scale_color_discrete(NULL, guide = guide_legend(override.aes = list(alpha = 1))) +
  theme_minimal() + theme(
    legend.position = c(1, 1) - 0.05, legend.justification = c(1, 1)
  )
```

```{r ribbons, echo=FALSE}
qtiled_dt <- sampledt[,{
  qs <- quantile(averted, probs = c(0.025, 0.5, 0.975))
  .(lo = qs[1], md = qs[2], hi = qs[3])
}, by = .(type, time)]

ggplot(qtiled_dt) + aes(time) +
  geom_ribbon(aes(fill = type, ymax = hi, ymin = lo), alpha = 0.25) +
  geom_line(aes(color = type, y = md)) +
  scale_color_discrete(
    NULL, aesthetics = c("color", "fill")
  ) +
  theme_minimal() + theme(
    legend.position = c(1, 1) - 0.05, legend.justification = c(1, 1)
  )
```

## Leftovers

TODO: also implement the purely compartmental version for maximum speed
comparison?

```{r}
#' @param t an integer scalar, the simulation time
#' @param y a factor vector, the individual states: S, I, R
#' @param parameters a list, `transmission_p`, `recovery_p`, `vaccination_p`,
#'   and `vax_t`
dStep_fast <- function(t, y, parameters) with(parameters, {

  Ninf <- y[infectious]
  Nsus <- y[susceptible]
  newinf <- rbinom(1, Nsus, 1-transmission_p^Ninf)
  newrem <- rbinom(1, Ninf, recovery_p)
  
  dY <- c(S = -newinf, I = newinf - newrem, R = newrem)

  if (t == vax_t) {
    newvax <- rbinom(1, Nsus - newinf, vaccination_p)
    dY[susceptible] <- dY[susceptible] - newvax
    dY[removed] <- dY[removed] + newvax
  }

  return(dY)
})
```
